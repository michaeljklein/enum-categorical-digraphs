-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/basic#readme</a>
@package basic
@version 0.1.0.0


-- | So we have a directed graph (digraph) that we want to represent a
--   category.
--   
--   <ul>
--   <li>All vertices must have at least one self-loop (id)</li>
--   <li>Composition of arcs is an arc, i.e. <tt>e(a,b) &amp;&amp; e(b, c)
--   =&gt; e(a, c)</tt></li>
--   </ul>
--   
--   0 is no arc, 1 is arc, 2 is anti-arc
--   
--   <pre>
--   forall i. e(i, i)
--   </pre>
--   
--   Final Result: <tt>allDGraphs :: Int -&gt; BTree (IntMap Neighborhood,
--   Matrix Int)</tt> Binary tree of choices for <tt>uncons</tt>: either
--   arc or anti arc
module Lib

-- | Triangular numbers
triNum :: Int -> Int

-- | A digraph arc
data Arc
Arc :: !Int -> !Int -> Arc
[arcHead] :: Arc -> !Int
[arcTail] :: Arc -> !Int

-- | The neighborhood of a vertex
data Neighborhood
Neighborhood :: IntSet -> IntSet -> Neighborhood
[inAdjacent] :: Neighborhood -> IntSet
[outAdjacent] :: Neighborhood -> IntSet

-- | <a>\\</a> set-wise
(\\\) :: Neighborhood -> Neighborhood -> Neighborhood

-- | Just the given vertex in the <a>outAdjacent</a>
pureIn :: Int -> Neighborhood

-- | Just the given vertex in the <a>inAdjacent</a>
pureOut :: Int -> Neighborhood

-- | Add to <a>inAdjacent</a>
addIn :: Int -> Neighborhood -> Neighborhood

-- | Add to <a>outAdjacent</a>
addOut :: Int -> Neighborhood -> Neighborhood

-- | Add an <a>Arc</a> to an <a>IntMap</a> of <a>Neighborhood</a>s
consNeighborhoods :: Arc -> IntMap Neighborhood -> IntMap Neighborhood

-- | Partially determined graph state
type PdState = StateT PdGraph Maybe
runPdState :: Int -> PdState a -> Maybe a
getPdState :: Int -> PdState a -> Maybe PdGraph

-- | Partially determined dighraphs
data PdGraph
PdGraph :: !Int -> !(Matrix Int) -> Set Arc -> IntMap Neighborhood -> PdGraph

-- | The number of vertices
[numVertices] :: PdGraph -> !Int

-- | Diagonal is 1, 0 -&gt; undetermined, 1 -&gt; arc, 2 -&gt; anti-arc
[adjMatrix] :: PdGraph -> !(Matrix Int)
[undeterminedArcs] :: PdGraph -> Set Arc

-- | The neighborhoods of each vertex
[neighborhoods] :: PdGraph -> IntMap Neighborhood

-- | Initial <a>PdGraph</a> with the given number of vertices
initPdGraph :: Int -> PdGraph

-- | Get the next undetermined <a>Arc</a> or <a>Nothing</a>
unconsUndetermined :: PdState (Maybe Arc)

-- | Both possible next determinations
bothChoices :: PdState (PdGraph, PdGraph)

-- | Make a list of choices
makeChoices :: [Bool] -> PdState ()

-- | Convert to list of bits (most significant bit last)
toBin :: Int -> [Bool]

-- | Pad with a value up to the given length
padWith :: Int -> a -> [a] -> [a]

-- | Indexed choices based on <a>toBin</a>
indexedChoices :: Int -> Int -> PdState ()

-- | All choices for a <a>PdGraph</a>
allChoices :: PdState [PdGraph]

-- | All choices for a <a>PdGraph</a> with the given number of vertices
allChoicesN :: Int -> [PdGraph]

-- | Assumes <a>Arc</a> gotten from <a>unconsUndetermined</a>
determineArc :: Int -> Int -> Int -> PdState ()

-- | Choose for an undetermined <a>Arc</a> to be an arc in the final
--   digraph
chooseArc :: Int -> Int -> PdState ()

-- | Choose for an undetermined <a>Arc</a> to _not_ be an arc in the final
--   digraph
chooseAnti :: Int -> Int -> PdState ()
arcCase :: Int -> Int -> PdState a -> PdState a -> PdState a -> PdState a
propagateChoseArc :: Int -> Int -> PdState ()
propagateChoseAnti :: Int -> Int -> PdState ()

-- | An implementation of <a>forM_</a> using <a>foldl'</a>
forM_IS :: Applicative f => IntSet -> (Int -> f ()) -> f ()

-- | An implementation of <a>mapM_</a> using <a>foldl'</a>
mapM_IS :: Applicative f => (Int -> f ()) -> IntSet -> f ()

-- | Throws an error if not ascending
assertIsAsc :: Ord a => [a] -> [a]
instance GHC.Generics.Generic Lib.PdGraph
instance GHC.Show.Show Lib.PdGraph
instance GHC.Classes.Eq Lib.PdGraph
instance GHC.Generics.Generic Lib.Neighborhood
instance GHC.Show.Show Lib.Neighborhood
instance GHC.Classes.Ord Lib.Neighborhood
instance GHC.Classes.Eq Lib.Neighborhood
instance GHC.Generics.Generic Lib.Arc
instance GHC.Show.Show Lib.Arc
instance GHC.Read.Read Lib.Arc
instance GHC.Classes.Ord Lib.Arc
instance GHC.Classes.Eq Lib.Arc
instance GHC.Base.Semigroup Lib.Neighborhood
instance GHC.Base.Monoid Lib.Neighborhood
